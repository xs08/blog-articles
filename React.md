# React 杂技

### `useMemo`&`useCallback`的使用场景
1. `useCallback`: 返回一个 memoized 回调函数。useCallback 是把内联回调函数及依赖项数组作为参数传入，然后返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当把回调函数传递给使用引用相等性去避免非必要渲染的子组件时，它非常有用。
2. `useMemo`: 返回一个 memoized 值。useMemo 把“创建”函数和依赖项数组作为参数传入，它仅会在某个依赖项改变时才重新计算 memoized 值，注意它得到的是一个值，useCallback得到的是一个回调函数。这种优化有助于避免在每次渲染时都进行高开销的计算。

换句话说，useCallback 提供了函数渲染之间的参照相等性。useMemo 提供值的渲染之间的参照相等性

> **注意**: 大多数情况下，你并不需要 memo，也就用不到这些API，请不要过度优化和提前优化。如果要执行的操作并不昂贵也就不需要记住返回值，那就不需要 useMemo。这种情况下 useMemo 的成本可能超过重新评估该功能的成本。 如果发现确实处于这种情况，应该重新评估：要记住的值不是昂贵的计算，而且在任何时间点都不会重新计算，这绝不符合“记忆”一词的定义。很多情况下我们对错误的理解和错误的使用了 useMemo Hook，这很可怕。从语义上讲这是错误的，并且可以说在内存分配和性能方面内卷了更多。

特殊使用情景：父组件需要传入函数、对象、数组等到子组件，且子组件需要依赖父组件的传入进行渲染时，由于JS的引用相等性(也就是每次重新计算子组件时，都会人会传入了新的props)都会导致子组件的重新渲染。这种情况下就可以对付组件需要传入子组件的props进行缓存，可以使用`useCallback`或者`useMemo`(**慎用**)